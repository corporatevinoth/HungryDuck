<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Duck Pond - Hunger Games</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; width: 250px; }
        #scoreDisplay { font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px #000; margin-bottom: 5px; }
        
        /* Hunger Bar Styling */
        #hunger-container { width: 100%; height: 20px; background: rgba(0,0,0,0.5); border: 2px solid white; border-radius: 10px; overflow: hidden; }
        #hunger-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ff4500, #32cd32); transition: width 0.3s; }
        
        #instructions { position: absolute; bottom: 20px; width: 100%; text-align: center; color: white; background: rgba(0,0,0,0.4); padding: 10px 0; }
    </style>
</head>
<body>

    <div id="ui">
        <div id="scoreDisplay">Size: 1.0x</div>
        <div style="margin-bottom: 5px; font-weight: bold; text-shadow: 1px 1px 2px #000;">Hunger</div>
        <div id="hunger-container">
            <div id="hunger-bar"></div>
        </div>
    </div>
    
    <div id="instructions">WASD or Arrows to Swim | Don't Starve!</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer, duck, water, clock;
        let bugs = [], clouds = [];
        let score = 1.0;
        let hunger = 100;
        const keys = {};

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 200);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(50, 50, 50);
            scene.add(sun, new THREE.AmbientLight(0xffffff, 0.7));

            createWater();
            createDuck();
            createEnvironment();
            spawnBugs();
            
            // FIXED CONTROLS: Listeners attached to window
            window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
            window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }

        function createWater() {
            const geo = new THREE.PlaneGeometry(500, 500, 100, 100);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x0066ff, 
                roughness: 0.1, 
                transparent: true, 
                opacity: 0.8 
            });
            water = new THREE.Mesh(geo, mat);
            water.rotation.x = -Math.PI / 2;
            scene.add(water);
        }

        function createDuck() {
            duck = new THREE.Group();
            const yellow = new THREE.MeshStandardMaterial({ color: 0xffd700 });
            
            const body = new THREE.Mesh(new THREE.SphereGeometry(1, 24, 24), yellow);
            body.scale.set(1, 0.8, 1.3);
            duck.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 24, 24), yellow);
            head.position.set(0, 0.9, 0.8);
            duck.add(head);

            const beak = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.4, 12), new THREE.MeshStandardMaterial({color: 0xff4500}));
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 0.9, 1.4);
            duck.add(beak);

            duck.position.y = 0.3;
            scene.add(duck);
        }

        function createEnvironment() {
            // Asymmetric Rocks & Trees
            for(let i = 0; i < 80; i++) {
                const x = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                if(Math.sqrt(x*x + z*z) < 20) continue;

                if(Math.random() > 0.5) {
                    const tree = new THREE.Group();
                    const leaves = new THREE.Mesh(
                        new THREE.ConeGeometry(1 + Math.random(), 3 + Math.random(), 7), 
                        new THREE.MeshStandardMaterial({color: 0x1a4d1a})
                    );
                    leaves.position.y = 1.5;
                    tree.add(leaves);
                    tree.position.set(x, 0, z);
                    scene.add(tree);
                } else {
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(1 + Math.random() * 2, 0), 
                        new THREE.MeshStandardMaterial({color: 0x666666})
                    );
                    rock.position.set(x, 0, z);
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    scene.add(rock);
                }
            }

            // Clouds
            for(let i = 0; i < 20; i++) {
                const cloud = new THREE.Group();
                const mat = new THREE.MeshLambertMaterial({color: 0xffffff, transparent: true, opacity: 0.8});
                for(let j = 0; j < 4; j++) {
                    const p = new THREE.Mesh(new THREE.SphereGeometry(2 + Math.random() * 2), mat);
                    p.position.set(j * 1.5, Math.random(), Math.random());
                    cloud.add(p);
                }
                cloud.position.set((Math.random()-0.5)*300, 25, (Math.random()-0.5)*300);
                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        function spawnBugs() {
            const bugGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const bugMat = new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0xff0000});
            for(let i = 0; i < 40; i++) {
                const bug = new THREE.Mesh(bugGeo, bugMat);
                bug.position.set((Math.random()-0.5)*200, 0.5, (Math.random()-0.5)*200);
                scene.add(bug);
                bugs.push(bug);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            const delta = clock.getDelta();

            // 1. Water Waves
            const pos = water.geometry.attributes.position.array;
            for(let i = 0; i < pos.length; i+=3) {
                pos[i+2] = Math.sin(pos[i]*0.2 + t) * 0.3 + Math.cos(pos[i+1]*0.2 + t) * 0.3;
            }
            water.geometry.attributes.position.needsUpdate = true;

            // 2. FIXED Movement Logic
            const moveSpeed = 0.25;
            const rotSpeed = 0.05;

            if(keys['w'] || keys['arrowup']) duck.translateZ(moveSpeed);
            if(keys['s'] || keys['arrowdown']) duck.translateZ(-moveSpeed/2);
            if(keys['a'] || keys['arrowleft']) duck.rotation.y += rotSpeed;
            if(keys['d'] || keys['arrowright']) duck.rotation.y -= rotSpeed;
            
            duck.position.y = Math.sin(t*2)*0.1 + 0.3; 

            // 3. Hunger Mechanic
            hunger -= 0.05; // Constant drain
            if(hunger <= 0) {
                hunger = 0;
                score = Math.max(0.5, score - 0.001); // Start shrinking
            }
            document.getElementById('hunger-bar').style.width = hunger + "%";

            // 4. Bug Collision & Growth
            bugs.forEach((bug, i) => {
                if(duck.position.distanceTo(bug.position) < (1.5 * score)) {
                    scene.remove(bug);
                    bugs.splice(i, 1);
                    score += 0.1;
                    hunger = Math.min(100, hunger + 20); // Eating refills hunger
                    duck.scale.set(score, score, score);
                    document.getElementById('scoreDisplay').innerText = `Size: ${score.toFixed(1)}x`;
                    
                    // Respawn bug elsewhere
                    setTimeout(spawnBugs, 2000); 
                }
            });

            // 5. Cloud Drift
            clouds.forEach(c => { c.position.x += 0.03; if(c.position.x > 200) c.position.x = -200; });

            // 6. Smooth Camera
            const camOffset = new THREE.Vector3(0, 8, -18).applyMatrix4(duck.matrixWorld);
            camera.position.lerp(camOffset, 0.1);
            camera.lookAt(duck.position);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
