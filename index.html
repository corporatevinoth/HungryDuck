<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D RACING · HUNGER 75% · SCORE 120</title>
    <!-- exact retro-futuristic vibe from screenshot -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Orbitron', 'Arial Black', sans-serif;
            overflow: hidden;
            background: #0c0c1a;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;800;900&display=swap');

        /* UI OVERLAY — pixel perfect like image: Score 120 left, Hunger 75% right with black boxes, yellow/red glow */
        #ui-overlay {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 40px;
            z-index: 100;
            pointer-events: none;
            filter: drop-shadow(0 0 12px #000000);
        }

        .score-block {
            background: #0f0f1e;
            border: 3px solid #f0b340;
            border-radius: 14px;
            padding: 12px 36px;
            box-shadow: 0 0 25px #ffaa33, inset 0 0 8px #ffcf8a;
            transform: skewX(-5deg) scale(1.05);
            backdrop-filter: blur(2px);
        }

        .score-block span {
            display: block;
            color: white;
            font-size: 4rem;
            font-weight: 900;
            line-height: 1;
            letter-spacing: 6px;
            text-shadow: 4px 4px 0 #b15d00, 0 0 20px #ffb347;
            transform: skewX(5deg); /* counter skew */
        }

        .score-block .label {
            font-size: 1.2rem;
            letter-spacing: 4px;
            color: #ffcf8a;
            text-align: right;
            text-shadow: 0 0 8px red;
            margin-top: -8px;
        }

        .hunger-block {
            background: #0f0f1e;
            border: 3px solid #e03a3a;
            border-radius: 14px;
            padding: 12px 36px;
            box-shadow: 0 0 30px #ff4d4d, inset 0 0 10px #ff8282;
            transform: skewX(-5deg) scale(1.05);
            backdrop-filter: blur(2px);
            text-align: right;
        }

        .hunger-block .main {
            color: white;
            font-size: 4rem;
            font-weight: 900;
            line-height: 1;
            letter-spacing: 8px;
            text-shadow: 4px 4px 0 #7a1f1f, 0 0 25px #ff7373;
            transform: skewX(5deg);
        }

        .hunger-block .label {
            font-size: 1.5rem;
            letter-spacing: 6px;
            color: #ffb0b0;
            text-shadow: 0 0 10px red;
            margin-top: -8px;
            transform: skewX(5deg);
        }

        /* subtle speed lines / decoration */
        .bottom-flare {
            position: absolute;
            bottom: 20px;
            left: 15%;
            width: 70%;
            height: 10px;
            background: linear-gradient(90deg, transparent, #ff7700, #ff3355, #ff7700, transparent);
            filter: blur(8px);
            border-radius: 100%;
            opacity: 0.6;
            z-index: 50;
        }

        .hint {
            position: absolute;
            bottom: 20px;
            left: 30px;
            color: #ffffff60;
            font-family: monospace;
            background: #00000070;
            padding: 6px 20px;
            border-radius: 40px;
            backdrop-filter: blur(4px);
            border: 1px solid #f0b34060;
            z-index: 200;
            font-size: 1rem;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- EXACT UI as screenshot: left Score 120, right Hunger 75% with black background & thick borders -->
    <div id="ui-overlay">
        <div class="score-block">
            <span>120</span>
            <div class="label">SCORE</div>
        </div>
        <div class="hunger-block">
            <div class="main">75%</div>
            <div class="label">HUNGER</div>
        </div>
    </div>
    <div class="bottom-flare"></div>
    <div class="hint">⬆️⬇️⬅️➡️  |  SHIFT boost  |  click to focus</div>

    <!-- Three.js + add-ons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // only for debug? not used

        // --- setup scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0e1f); // deep dark blue
        scene.fog = new THREE.FogExp2(0x0b0e1f, 0.025);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 4, 14);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // --- postprocessing bloom (for that neon glow) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- lights ---
        const ambient = new THREE.AmbientLight(0x404080);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.0);
        dirLight.position.set(2, 15, 10);
        dirLight.castShadow = true;
        dirLight.receiveShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        const d = 20;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.near = 2;
        dirLight.shadow.camera.far = 40;
        scene.add(dirLight);

        const fillLight = new THREE.PointLight(0x4466cc, 0.6);
        fillLight.position.set(-3, 5, 15);
        scene.add(fillLight);

        // ground with reflective/glossy look
        const groundGeo = new THREE.CircleGeometry(200, 64);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x15182e, roughness: 0.3, metalness: 0.7, emissive: 0x020210 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // decorative grid (cyber)
        const gridHelper = new THREE.GridHelper(200, 50, 0xff9933, 0x3366cc);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // --- track markers / neon columns (makes it feel like racing scene) ---
        const pillarMat = new THREE.MeshStandardMaterial({ color: 0xffaa33, emissive: 0x552200 });
        for (let i = 0; i < 24; i++) {
            const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.4, 1.8, 8), pillarMat);
            pillar.castShadow = true;
            pillar.receiveShadow = true;
            const side = (i % 2 === 0) ? -5 : 5;
            const z = i * 4 + 10;
            pillar.position.set(side, 0.9, z);
            scene.add(pillar);
            
            // glowing tip
            const tip = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8), new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0xff4400 }));
            tip.position.set(side, 1.8, z);
            scene.add(tip);
        }

        // floating neon particles (speed lines)
        const particleCount = 600;
        const particleGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            positions[i*3] = (Math.random() - 0.5) * 180;
            positions[i*3+1] = Math.random() * 12;
            positions[i*3+2] = (Math.random() * 200) - 40;
            
            const col = new THREE.Color().setHSL(0.05 + Math.random()*0.1, 1, 0.6);
            colors[i*3] = col.r;
            colors[i*3+1] = col.g;
            colors[i*3+2] = col.b;
        }
        particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const particleMat = new THREE.PointsMaterial({ size: 0.25, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);

        // --- CAR (low poly but detailed, matching screenshot vibe) ---
        const carGroup = new THREE.Group();

        // body (main chassis)
        const bodyGeo = new THREE.BoxGeometry(2.2, 0.7, 4.2);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xc02030, roughness: 0.2, metalness: 0.6, emissive: 0x330000 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.castShadow = true;
        body.receiveShadow = true;
        body.position.y = 0.7;
        body.position.z = 0;
        carGroup.add(body);

        // cabin (translucent / dark glass)
        const cabinGeo = new THREE.BoxGeometry(1.4, 0.7, 1.8);
        const cabinMat = new THREE.MeshStandardMaterial({ color: 0x224488, roughness: 0.1, metalness: 0.2, emissive: 0x112233, transparent: true, opacity: 0.8 });
        const cabin = new THREE.Mesh(cabinGeo, cabinMat);
        cabin.castShadow = true;
        cabin.receiveShadow = true;
        cabin.position.set(0, 1.2, -0.2);
        carGroup.add(cabin);

        // front grill / headlights
        const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc88, emissive: 0x884400 });
        const headL = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8), headMat);
        headL.rotation.x = Math.PI/2;
        headL.position.set(-0.8, 0.8, 2.0);
        carGroup.add(headL);
        const headR = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8), headMat);
        headR.rotation.x = Math.PI/2;
        headR.position.set(0.8, 0.8, 2.0);
        carGroup.add(headR);

        // wheels with chrome
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3 });
        const rimMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.9, roughness: 0.1 });
        const positions = [[-1.3, 0.5, 1.5], [1.3, 0.5, 1.5], [-1.3, 0.5, -1.4], [1.3, 0.5, -1.4]];
        positions.forEach(pos => {
            const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.5, 24), wheelMat);
            wheel.rotation.z = Math.PI/2;
            wheel.position.set(pos[0], pos[1], pos[2]);
            wheel.castShadow = true;
            wheel.receiveShadow = true;
            carGroup.add(wheel);
            
            const rim = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.51, 8), rimMat);
            rim.rotation.z = Math.PI/2;
            rim.position.set(pos[0], pos[1], pos[2]);
            rim.castShadow = true;
            carGroup.add(rim);
        });

        // rear spoiler
        const spoilerMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const spoiler = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.2, 0.3), spoilerMat);
        spoiler.position.set(0, 1.4, -1.8);
        spoiler.castShadow = true;
        carGroup.add(spoiler);

        carGroup.position.set(0, 0.7, 10);
        carGroup.rotation.y = 0; // face +Z
        scene.add(carGroup);

        // --- obstacles / tokens to give racing feel (like checkpoints) ---
        const tokenMat = new THREE.MeshStandardMaterial({ color: 0xffaa22, emissive: 0x442200 });
        for (let i = 0; i < 10; i++) {
            const token = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.1, 8, 20), tokenMat);
            token.rotation.x = Math.PI/2;
            token.position.set((Math.random()-0.5)*6, 1.0, 20 + i*8);
            token.castShadow = true;
            token.receiveShadow = true;
            scene.add(token);
        }

        // --- input handling ---
        const keyState = {
            w: false, a: false, s: false, d: false, shift: false,
            arrowup: false, arrowdown: false, arrowleft: false, arrowright: false
        };
        window.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keyState.w = true; e.preventDefault(); break;
                case 'KeyA': keyState.a = true; e.preventDefault(); break;
                case 'KeyS': keyState.s = true; e.preventDefault(); break;
                case 'KeyD': keyState.d = true; e.preventDefault(); break;
                case 'ShiftLeft': case 'ShiftRight': keyState.shift = true; e.preventDefault(); break;
                case 'ArrowUp': keyState.arrowup = true; e.preventDefault(); break;
                case 'ArrowDown': keyState.arrowdown = true; e.preventDefault(); break;
                case 'ArrowLeft': keyState.arrowleft = true; e.preventDefault(); break;
                case 'ArrowRight': keyState.arrowright = true; e.preventDefault(); break;
            }
        });
        window.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keyState.w = false; e.preventDefault(); break;
                case 'KeyA': keyState.a = false; e.preventDefault(); break;
                case 'KeyS': keyState.s = false; e.preventDefault(); break;
                case 'KeyD': keyState.d = false; e.preventDefault(); break;
                case 'ShiftLeft': case 'ShiftRight': keyState.shift = false; e.preventDefault(); break;
                case 'ArrowUp': keyState.arrowup = false; e.preventDefault(); break;
                case 'ArrowDown': keyState.arrowdown = false; e.preventDefault(); break;
                case 'ArrowLeft': keyState.arrowleft = false; e.preventDefault(); break;
                case 'ArrowRight': keyState.arrowright = false; e.preventDefault(); break;
            }
        });

        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        // --- game variables ---
        let speed = 0;
        const maxSpeed = 0.9;
        const turnSpeed = 0.022;
        const cameraOffset = new THREE.Vector3(-3, 2.8, 7); // behind and above

        // --- animation loop ---
        function animate() {
            requestAnimationFrame(animate);

            // forward/back
            let forward = 0;
            if (keyState.w || keyState.arrowup) forward = 1;
            else if (keyState.s || keyState.arrowdown) forward = -1;

            let turn = 0;
            if (keyState.a || keyState.arrowleft) turn = 1;
            else if (keyState.d || keyState.arrowright) turn = -1;

            const boost = (keyState.shift) ? 2.0 : 1.0;

            if (forward !== 0) {
                speed += forward * 0.015 * boost;
                if (Math.abs(speed) > maxSpeed * boost) speed = Math.sign(speed) * maxSpeed * boost;
            } else {
                speed *= 0.98;
            }

            if (Math.abs(speed) > 0.02) {
                carGroup.rotation.y += turn * turnSpeed * Math.sign(speed) * (boost * 0.8);
            }

            // move
            const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(carGroup.quaternion);
            carGroup.position.addScaledVector(forwardDir, speed);

            // boundary
            if (carGroup.position.x < -7) carGroup.position.x = -7;
            if (carGroup.position.x > 7) carGroup.position.x = 7;

            // camera follow (smooth-ish)
            const idealOffset = cameraOffset.clone().applyQuaternion(carGroup.quaternion);
            camera.position.lerp(carGroup.position.clone().add(idealOffset), 0.1);
            camera.lookAt(carGroup.position.clone().add(new THREE.Vector3(0, 1.5, 0)));

            // particle animation
            particles.rotation.y += 0.0002;

            // bloom composer render
            composer.render();
        }

        animate();

        // --- resize handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // add some floating glowing spheres that resemble "hunger" orbs
        for (let j = 0; j < 6; j++) {
            const orbMat = new THREE.MeshStandardMaterial({ color: 0xff4433, emissive: 0x441100 });
            const orb = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16), orbMat);
            orb.position.set( (j%3-1)*3, 1.5, 30 + j*10 );
            orb.castShadow = true;
            scene.add(orb);
        }

        // add faint volumetric light beams (using simple planes with transparency)
        const beamMat = new THREE.MeshBasicMaterial({ color: 0xff8822, transparent: true, opacity: 0.05, side: THREE.DoubleSide });
        for (let k = 0; k < 8; k++) {
            const beam = new THREE.Mesh(new THREE.PlaneGeometry(1, 20), beamMat);
            beam.position.set(-4 + k*1.2, 5, 30 + k*5);
            beam.rotation.x = Math.PI/4;
            beam.rotation.z = 0.2;
            scene.add(beam);
        }

        console.log('✅ Game running — Score 120, Hunger 75%');
    </script>
</body>
</html>
