<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Odyssey: Misty Ocean World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            overflow: hidden;
            background: #000;
            color: #fff;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            pointer-events: none;
        }
        
        #title {
            text-align: center;
            padding: 20px;
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(255, 255, 200, 0.7);
            color: #ffec8b;
            letter-spacing: 2px;
            background: linear-gradient(transparent, rgba(0, 20, 40, 0.7));
        }
        
        #subtitle {
            position: absolute;
            bottom: 150px;
            width: 100%;
            text-align: center;
            font-size: 1.5rem;
            text-shadow: 0 0 10px rgba(0, 100, 255, 0.7);
            color: #a3d5ff;
            padding: 15px 30px;
            background: rgba(0, 20, 40, 0.6);
            border-radius: 10px;
            margin: 0 auto;
            max-width: 800px;
            left: 50%;
            transform: translateX(-50%);
            transition: opacity 0.5s;
            opacity: 0;
        }
        
        #stats {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 20, 40, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 1.2rem;
            min-width: 250px;
        }
        
        .stat-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .stat-value {
            color: #ffec8b;
            font-weight: bold;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 1rem;
            max-width: 300px;
        }
        
        #controls h3 {
            color: #ffec8b;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .control-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            margin: 0 5px;
            border-radius: 5px;
            min-width: 30px;
            text-align: center;
            font-weight: bold;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a192f;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-top: 5px solid #4dabf7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #loadingText {
            font-size: 1.5rem;
            color: #a3d5ff;
        }
        
        #loadingProgress {
            width: 200px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        #loadingBar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4dabf7, #da77f2);
            transition: width 0.3s;
        }
        
        .feather {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ffec8b, #ffd43b);
            border-radius: 50%;
            box-shadow: 0 0 15px #ffec8b;
            z-index: 50;
            pointer-events: none;
        }
        
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 1.8rem;
            text-align: center;
            color: #ffec8b;
            text-shadow: 0 0 10px rgba(255, 255, 200, 0.7);
            z-index: 150;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            max-width: 600px;
            border: 2px solid rgba(255, 236, 139, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <h1 id="title">Duck Odyssey: Misty Ocean World</h1>
            <div id="subtitle"></div>
            <div id="stats">
                <h3>Duck Stats</h3>
                <div class="stat-item">
                    <span>Feathers Collected:</span>
                    <span id="featherCount" class="stat-value">0 / 10</span>
                </div>
                <div class="stat-item">
                    <span>Islands Discovered:</span>
                    <span id="islandCount" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                    <span>Distance Traveled:</span>
                    <span id="distance" class="stat-value">0 m</span>
                </div>
                <div class="stat-item">
                    <span>Waterfalls Found:</span>
                    <span id="waterfalls" class="stat-value">0</span>
                </div>
            </div>
            <div id="controls">
                <h3>Controls</h3>
                <div class="control-item">
                    <span>Move:</span>
                    <div class="key">W</div>
                    <div class="key">A</div>
                    <div class="key">S</div>
                    <div class="key">D</div>
                </div>
                <div class="control-item">
                    <span>Look:</span>
                    <span>Mouse Drag</span>
                </div>
                <div class="control-item">
                    <span>Speed Up:</span>
                    <div class="key">SHIFT</div>
                </div>
                <div class="control-item">
                    <span>Quack:</span>
                    <div class="key">Q</div>
                </div>
            </div>
        </div>
        
        <div id="loading">
            <div class="loader"></div>
            <div id="loadingText">Loading Misty Ocean World...</div>
            <div id="loadingProgress">
                <div id="loadingBar"></div>
            </div>
        </div>
        
        <div id="message"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Game State
        const gameState = {
            feathers: 0,
            maxFeathers: 10,
            islandsDiscovered: 0,
            distanceTraveled: 0,
            waterfallsFound: 0,
            lastPosition: { x: 0, y: 0, z: 0 },
            subtitles: [
                "Quack! I've reached the Misty Pond!",
                "What a beautiful, glowing fog...",
                "These floating islands are amazing!",
                "I wonder where these waterfalls lead?",
                "Shiny feathers! I should collect them.",
                "The dawn light makes everything magical.",
                "Quack! I feel so brave today!",
                "This water feels strange... and wonderful!",
                "I can see so far from up here!",
                "Time to explore every corner of this world!"
            ],
            currentSubtitle: 0,
            subtitlesEnabled: true
        };

        // DOM Elements
        const loadingScreen = document.getElementById('loading');
        const loadingBar = document.getElementById('loadingBar');
        const loadingText = document.getElementById('loadingText');
        const subtitleElement = document.getElementById('subtitle');
        const featherCountElement = document.getElementById('featherCount');
        const islandCountElement = document.getElementById('islandCount');
        const distanceElement = document.getElementById('distance');
        const waterfallsElement = document.getElementById('waterfalls');
        const messageElement = document.getElementById('message');

        // Three.js variables
        let scene, camera, renderer, controls;
        let duck, water, islands = [], feathers = [], waterfalls = [];
        let clock = new THREE.Clock();
        let waterUniforms;
        
        // Initialize the game
        function init() {
            // Update loading screen
            loadingText.textContent = "Initializing 3D scene...";
            loadingBar.style.width = '10%';
            
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xa3d5ff, 0.005);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 5, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            
            loadingBar.style.width = '20%';
            loadingText.textContent = "Setting up lighting...";
            
            // Add lighting
            setupLighting();
            
            loadingBar.style.width = '30%';
            loadingText.textContent = "Creating ocean world...";
            
            // Create water
            createWater();
            
            loadingBar.style.width = '40%';
            loadingText.textContent = "Generating floating islands...";
            
            // Create islands
            createIslands();
            
            loadingBar.style.width = '50%';
            loadingText.textContent = "Adding waterfalls...";
            
            // Create waterfalls
            createWaterfalls();
            
            loadingBar.style.width = '60%';
            loadingText.textContent = "Creating our brave duck...";
            
            // Create duck
            createDuck();
            
            loadingBar.style.width = '70%';
            loadingText.textContent = "Adding shiny feathers...";
            
            // Create feathers
            createFeathers();
            
            loadingBar.style.width = '80%';
            loadingText.textContent = "Adding atmospheric effects...";
            
            // Add particles for glowing fog
            createFogParticles();
            
            loadingBar.style.width = '90%';
            loadingText.textContent = "Finalizing rendering...";
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            
            // Hide loading screen
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                    showMessage("Welcome to Misty Ocean World! Use WASD to swim and explore!");
                }, 1000);
            }, 500);
            
            loadingBar.style.width = '100%';
            
            // Start game loop
            animate();
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffecd2, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Dawn-colored fill light
            const dawnLight = new THREE.DirectionalLight(0xffb6c1, 0.4);
            dawnLight.position.set(-50, 30, -30);
            scene.add(dawnLight);
            
            // Add point lights for glowing effect
            const pointLight1 = new THREE.PointLight(0x4dabf7, 0.5, 100);
            pointLight1.position.set(30, 10, 20);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xda77f2, 0.5, 100);
            pointLight2.position.set(-20, 15, -30);
            scene.add(pointLight2);
        }
        
        function createWater() {
            // Create water geometry
            const waterGeometry = new THREE.PlaneGeometry(500, 500, 32, 32);
            
            // Water material with custom shaders for realistic effect
            const waterMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x0a2948) },
                    color2: { value: new THREE.Color(0x1a4f8c) },
                    fogColor: { value: new THREE.Color(0xa3d5ff) },
                    fogDensity: { value: 0.01 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        
                        // Create wave effect
                        float wave = sin(position.x * 0.1 + time) * cos(position.z * 0.1 + time) * 0.5;
                        vec3 pos = position;
                        pos.y += wave;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color1;
                    uniform vec3 color2;
                    uniform vec3 fogColor;
                    uniform float fogDensity;
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    
                    void main() {
                        // Create gradient water color
                        float depthFactor = clamp(vPosition.y * 0.1, 0.0, 1.0);
                        vec3 waterColor = mix(color1, color2, depthFactor);
                        
                        // Add foam effect
                        float foam = sin(vPosition.x * 0.2 + vPosition.z * 0.2 + time * 2.0) * 0.5 + 0.5;
                        foam = smoothstep(0.4, 0.6, foam);
                        waterColor = mix(waterColor, vec3(1.0), foam * 0.2);
                        
                        // Add glow
                        float glow = sin(vPosition.x * 0.05 + time) * cos(vPosition.z * 0.05 + time * 0.7) * 0.5 + 0.5;
                        waterColor += glow * 0.1 * vec3(0.5, 0.7, 1.0);
                        
                        // Apply fog
                        float depth = gl_FragCoord.z / gl_FragCoord.w;
                        float fogFactor = 1.0 - exp(-fogDensity * fogDensity * depth * depth);
                        waterColor = mix(waterColor, fogColor, fogFactor);
                        
                        gl_FragColor = vec4(waterColor, 0.9);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            waterUniforms = waterMaterial.uniforms;
            
            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -2;
            water.receiveShadow = true;
            scene.add(water);
        }
        
        function createIslands() {
            const islandCount = 15;
            
            for (let i = 0; i < islandCount; i++) {
                // Create island group
                const islandGroup = new THREE.Group();
                
                // Random position in a circular pattern
                const angle = (i / islandCount) * Math.PI * 2;
                const radius = 20 + Math.random() * 80;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = -1 + Math.random() * 5;
                
                // Create island base (rocky terrain)
                const geometry = new THREE.SphereGeometry(3 + Math.random() * 5, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x7a7a7a,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const islandBase = new THREE.Mesh(geometry, material);
                islandBase.castShadow = true;
                islandBase.receiveShadow = true;
                islandGroup.add(islandBase);
                
                // Add some rocks on top
                const rockCount = 5 + Math.floor(Math.random() * 10);
                for (let j = 0; j < rockCount; j++) {
                    const rockSize = 0.5 + Math.random() * 1.5;
                    const rockGeometry = new THREE.SphereGeometry(rockSize, 16, 16);
                    const rockMaterial = new THREE.MeshStandardMaterial({
                        color: 0x5a5a5a,
                        roughness: 0.9
                    });
                    
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(
                        (Math.random() - 0.5) * 4,
                        2 + Math.random() * 3,
                        (Math.random() - 0.5) * 4
                    );
                    rock.castShadow = true;
                    rock.receiveShadow = true;
                    islandGroup.add(rock);
                }
                
                // Add some vegetation
                if (Math.random() > 0.3) {
                    const grassGeometry = new THREE.ConeGeometry(0.5, 2, 8);
                    const grassMaterial = new THREE.MeshStandardMaterial({
                        color: 0x3a7a3a,
                        roughness: 0.9
                    });
                    
                    const grassCount = 3 + Math.floor(Math.random() * 5);
                    for (let j = 0; j < grassCount; j++) {
                        const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                        grass.position.set(
                            (Math.random() - 0.5) * 3,
                            3,
                            (Math.random() - 0.5) * 3
                        );
                        grass.castShadow = true;
                        islandGroup.add(grass);
                    }
                }
                
                // Position the island
                islandGroup.position.set(x, y, z);
                islandGroup.userData = {
                    id: i,
                    discovered: false,
                    type: 'island'
                };
                
                islands.push(islandGroup);
                scene.add(islandGroup);
                
                // Check if this is the starting island
                if (i === 0) {
                    islandGroup.userData.discovered = true;
                    gameState.islandsDiscovered++;
                    islandCountElement.textContent = gameState.islandsDiscovered;
                }
            }
        }
        
        function createWaterfalls() {
            const waterfallCount = 8;
            
            for (let i = 0; i < waterfallCount; i++) {
                // Create waterfall group
                const waterfallGroup = new THREE.Group();
                
                // Find an island to attach the waterfall to
                const islandIndex = Math.floor(Math.random() * islands.length);
                const island = islands[islandIndex];
                
                // Create waterfall particles
                const particleCount = 200;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                const color = new THREE.Color(0x4dabf7);
                
                for (let j = 0; j < particleCount; j++) {
                    // Position particles in a vertical stream
                    const i3 = j * 3;
                    positions[i3] = (Math.random() - 0.5) * 2;
                    positions[i3 + 1] = Math.random() * 15;
                    positions[i3 + 2] = (Math.random() - 0.5) * 2;
                    
                    // Vary the color slightly
                    colors[i3] = color.r * (0.8 + Math.random() * 0.2);
                    colors[i3 + 1] = color.g * (0.8 + Math.random() * 0.2);
                    colors[i3 + 2] = color.b * (0.8 + Math.random() * 0.2);
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7
                });
                
                const waterfall = new THREE.Points(particles, particleMaterial);
                waterfallGroup.add(waterfall);
                
                // Position waterfall on the side of the island
                const angle = Math.random() * Math.PI * 2;
                const distance = 4;
                waterfallGroup.position.set(
                    Math.cos(angle) * distance,
                    5,
                    Math.sin(angle) * distance
                );
                
                waterfallGroup.userData = {
                    id: i,
                    found: false,
                    type: 'waterfall',
                    particleSystem: waterfall,
                    time: 0
                };
                
                // Add to island
                island.add(waterfallGroup);
                waterfalls.push(waterfallGroup);
            }
        }
        
        function createDuck() {
            // Create duck group
            duck = new THREE.Group();
            
            // Duck body (main sphere)
            const bodyGeometry = new THREE.SphereGeometry(1, 16, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd43b,
                roughness: 0.7,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            duck.add(body);
            
            // Duck head (smaller sphere)
            const headGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd43b,
                roughness: 0.7,
                metalness: 0.1
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.8, 0.5, 0);
            head.castShadow = true;
            duck.add(head);
            
            // Duck beak
            const beakGeometry = new THREE.ConeGeometry(0.15, 0.5, 8);
            const beakMaterial = new THREE.MeshStandardMaterial({
                color: 0xff6b35,
                roughness: 0.5
            });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(1.3, 0.5, 0);
            beak.rotation.z = Math.PI / 2;
            beak.castShadow = true;
            duck.add(beak);
            
            // Duck tail
            const tailGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const tailMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd43b,
                roughness: 0.7,
                metalness: 0.1
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.9, 0, 0);
            tail.rotation.z = -Math.PI / 2;
            tail.castShadow = true;
            duck.add(tail);
            
            // Duck wings
            const wingGeometry = new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd43b,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // Left wing
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(0, 0, 0.7);
            leftWing.rotation.x = Math.PI / 4;
            leftWing.castShadow = true;
            duck.add(leftWing);
            
            // Right wing
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0, 0, -0.7);
            rightWing.rotation.x = -Math.PI / 4;
            rightWing.castShadow = true;
            duck.add(rightWing);
            
            // Duck eyes
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.1,
                metalness: 0.5
            });
            
            // Left eye
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.9, 0.7, 0.3);
            duck.add(leftEye);
            
            // Right eye
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.9, 0.7, -0.3);
            duck.add(rightEye);
            
            // Position duck at starting point
            duck.position.set(0, 0, 0);
            duck.scale.set(0.8, 0.8, 0.8);
            duck.userData = {
                speed: 0,
                maxSpeed: 0.2,
                acceleration: 0.01,
                    deceleration: 0.02,
                    rotationSpeed: 0.05,
                    velocity: new THREE.Vector3(),
                    isMoving: false,
                    wingFlapSpeed: 0
                };
                
                scene.add(duck);
                
                // Set camera to follow duck
                controls.target.copy(duck.position);
            }
            
            function createFeathers() {
                const featherCount = gameState.maxFeathers;
                
                for (let i = 0; i < featherCount; i++) {
                    // Create feather geometry
                    const featherGroup = new THREE.Group();
                    
                    // Feather shaft
                    const shaftGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.8, 8);
                    const shaftMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.3,
                        metalness: 0.5,
                        emissive: 0x222222
                    });
                    const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                    featherGroup.add(shaft);
                    
                    // Feather vane (as a triangle)
                    const vaneGeometry = new THREE.ConeGeometry(0.4, 0.6, 3);
                    const vaneMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffec8b,
                        roughness: 0.2,
                        metalness: 0.7,
                        emissive: 0x443300,
                        emissiveIntensity: 0.5
                    });
                    const vane = new THREE.Mesh(vaneGeometry, vaneMaterial);
                    vane.position.set(0, 0.4, 0);
                    vane.rotation.x = Math.PI;
                    featherGroup.add(vane);
                    
                    // Position feather randomly in the world
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * 70;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    // Put feather on an island or floating
                    const y = Math.random() > 0.5 ? 2 + Math.random() * 5 : 0.5;
                    
                    featherGroup.position.set(x, y, z);
                    featherGroup.rotation.y = Math.random() * Math.PI * 2;
                    featherGroup.rotation.x = Math.random() * 0.5;
                    
                    featherGroup.userData = {
                        id: i,
                        collected: false,
                        type: 'feather',
                        rotationSpeed: 0.01 + Math.random() * 0.02,
                        floatSpeed: 0.5 + Math.random() * 0.5,
                        floatOffset: Math.random() * Math.PI * 2
                    };
                    
                    feathers.push(featherGroup);
                    scene.add(featherGroup);
                    
                    // Also create a DOM element for visual effect when collected
                    const featherElement = document.createElement('div');
                    featherElement.className = 'feather';
                    featherElement.style.left = '50%';
                    featherElement.style.top = '50%';
                    featherElement.style.opacity = '0';
                    document.getElementById('gameContainer').appendChild(featherElement);
                }
            }
            
            function createFogParticles() {
                // Create glowing fog particles
                const particleCount = 500;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                const color = new THREE.Color(0xa3d5ff);
                
                for (let i = 0; i < particleCount; i++) {
                    // Position particles randomly in the world
                    const i3 = i * 3;
                    positions[i3] = (Math.random() - 0.5) * 200;
                    positions[i3 + 1] = Math.random() * 30;
                    positions[i3 + 2] = (Math.random() - 0.5) * 200;
                    
                    // Vary the color slightly
                    colors[i3] = color.r * (0.7 + Math.random() * 0.3);
                    colors[i3 + 1] = color.g * (0.7 + Math.random() * 0.3);
                    colors[i3 + 2] = color.b * (0.7 + Math.random() * 0.3);
                    
                    // Random size
                    sizes[i] = Math.random() * 2 + 0.5;
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const particleMaterial = new THREE.PointsMaterial({
                    size: 1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                const fogParticles = new THREE.Points(particles, particleMaterial);
                scene.add(fogParticles);
            }
            
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            function onKeyDown(event) {
                // Quack key
                if (event.key === 'q' || event.key === 'Q') {
                    showSubtitle("Quack! Quack!");
                    return;
                }
                
                // Speed boost
                if (event.key === 'Shift') {
                    duck.userData.maxSpeed = 0.4;
                    return;
                }
            }
            
            function updateDuckMovement() {
                const delta = clock.getDelta();
                const keys = {
                    w: false, a: false, s: false, d: false
                };
                
                // Check key states
                if (keys.w = (isKeyPressed('W') || isKeyPressed('w'))) duck.userData.isMoving = true;
                if (keys.s = (isKeyPressed('S') || isKeyPressed('s'))) duck.userData.isMoving = true;
                if (keys.a = (isKeyPressed('A') || isKeyPressed('a'))) duck.userData.isMoving = true;
                if (keys.d = (isKeyPressed('D') || isKeyPressed('d'))) duck.userData.isMoving = true;
                
                // Reset speed if no keys pressed
                if (!keys.w && !keys.a && !keys.s && !keys.d) {
                    duck.userData.isMoving = false;
                }
                
                // Update duck speed
                if (duck.userData.isMoving) {
                    duck.userData.speed = Math.min(duck.userData.speed + duck.userData.acceleration, duck.userData.maxSpeed);
                } else {
                    duck.userData.speed = Math.max(duck.userData.speed - duck.userData.deceleration, 0);
                }
                
                // Calculate movement direction
                const moveDirection = new THREE.Vector3();
                
                if (keys.w) moveDirection.z -= 1;
                if (keys.s) moveDirection.z += 1;
                if (keys.a) moveDirection.x -= 1;
                if (keys.d) moveDirection.x += 1;
                
                // Normalize direction if moving diagonally
                if (moveDirection.length() > 0) {
                    moveDirection.normalize();
                    
                    // Rotate duck to face movement direction
                    const targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
                    duck.rotation.y = THREE.MathUtils.lerp(duck.rotation.y, targetRotation, duck.userData.rotationSpeed);
                    
                    // Move duck
                    duck.position.x += move
