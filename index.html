<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Surreal Duck Pond</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1e3f5a; font-family: 'Arial Rounded MT Bold', sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; width: 280px; pointer-events: none; z-index: 10; }
        #scoreDisplay { font-size: 28px; text-shadow: 3px 3px 6px #000; color: #00f2ff; }
        #hunger-container { width: 100%; height: 12px; background: rgba(0,0,0,0.4); border: 1px solid #fff; border-radius: 6px; margin-top: 10px; overflow: hidden; }
        #hunger-bar { width: 100%; height: 100%; background: #00ffcc; transition: width 0.2s; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.6); color: white; z-index: 100; text-align: center; }
        button { padding: 15px 40px; font-size: 20px; cursor: pointer; border: none; border-radius: 30px; background: #00f2ff; color: #003344; font-weight: bold; margin-top: 20px; }
    </style>
</head>
<body>

    <div id="ui">
        <div id="scoreDisplay">Score: 0</div>
        <div id="hunger-container"><div id="hunger-bar"></div></div>
    </div>

    <div id="overlay">
        <h1>SURREAL POND</h1>
        <p>Controls: WASD / Arrows</p>
        <button id="startBtn">SWIM</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer, duck, water, clock;
        let bugs = [], fishes = [], wakes = [];
        let score = 0, hunger = 100, isPlaying = false;
        const keys = {};

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e3f5a);
            scene.fog = new THREE.Fog(0x1e3f5a, 20, 180);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const sun = new THREE.DirectionalLight(0xffffff, 2);
            sun.position.set(10, 20, 10);
            scene.add(sun, new THREE.AmbientLight(0xffffff, 0.4));

            createWater();
            createDuck();
            spawnEnvironment(); 
            
            document.addEventListener('keydown', (e) => keys[e.code] = true);
            document.addEventListener('keyup', (e) => keys[e.code] = false);
            document.getElementById('startBtn').onclick = () => { isPlaying = true; document.getElementById('overlay').style.display='none'; };
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }

        function createWater() {
            const geo = new THREE.PlaneGeometry(1000, 1000, 128, 128);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x00aaff, 
                transparent: true, 
                opacity: 0.6, // Transparent water
                roughness: 0,
                metalness: 0.2
            });
            water = new THREE.Mesh(geo, mat);
            water.rotation.x = -Math.PI / 2;
            scene.add(water);
        }

        function createDuck() {
            duck = new THREE.Group();
            const body = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16), new THREE.MeshStandardMaterial({color: 0xffcc00}));
            body.scale.set(1, 0.7, 1.2);
            duck.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshStandardMaterial({color: 0xffcc00}));
            head.position.set(0, 0.7, 0.7);
            duck.add(head);
            duck.position.y = 0.2;
            scene.add(duck);
        }

        function spawnEnvironment() {
            // Spawn Fishes
            const fishGeo = new THREE.CapsuleGeometry(0.1, 0.4, 4, 8);
            const fishMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa, metalness: 0.8});
            for(let i=0; i<40; i++) {
                const fish = new THREE.Mesh(fishGeo, fishMat);
                fish.position.set((Math.random()-0.5)*200, -1.5, (Math.random()-0.5)*200);
                scene.add(fish);
                fishes.push({mesh: fish, angle: Math.random()*Math.PI*2});
            }

            // Spawn Bugs
            const bugGeo = new THREE.SphereGeometry(0.3);
            const bugMat = new THREE.MeshStandardMaterial({color: 0xff4444, emissive: 0xff0000});
            for(let i=0; i<30; i++) {
                const bug = new THREE.Mesh(bugGeo, bugMat);
                bug.position.set((Math.random()-0.5)*150, 0.5, (Math.random()-0.5)*150);
                scene.add(bug);
                bugs.push(bug);
            }
        }

        // --- Surreal Wake Effect ---
        function createWake() {
            const wakeGeo = new THREE.RingGeometry(0.5, 0.7, 32);
            const wakeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            const wake = new THREE.Mesh(wakeGeo, wakeMat);
            wake.position.set(duck.position.x, 0.05, duck.position.z);
            wake.rotation.x = -Math.PI / 2;
            scene.add(wake);
            wakes.push({ mesh: wake, life: 1.0 });
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            // 1. Dynamic Surreal Waves
            const pos = water.geometry.attributes.position.array;
            for(let i = 0; i < pos.length; i+=3) {
                // Larger, visible wave function
                pos[i+2] = Math.sin(pos[i]*0.2 + t*1.5) * 0.5 + Math.cos(pos[i+1]*0.2 + t*1.5) * 0.5;
            }
            water.geometry.attributes.position.needsUpdate = true;

            if (isPlaying) {
                let moving = false;
                if(keys['KeyW'] || keys['ArrowUp']) { duck.translateZ(0.3); moving = true; }
                if(keys['KeyS'] || keys['ArrowDown']) { duck.translateZ(-0.15); moving = true; }
                if(keys['KeyA'] || keys['ArrowLeft']) duck.rotation.y += 0.05;
                if(keys['KeyD'] || keys['ArrowRight']) duck.rotation.y -= 0.05;

                // Create wake path if moving forward
                if(moving && Math.random() > 0.7) createWake();

                // Hunger
                hunger -= 0.05;
                document.getElementById('hunger-bar').style.width = hunger + "%";
                if(hunger <= 0) score = Math.max(0, score - 0.1);

                // Collections
                bugs.forEach((bug, i) => {
                    if(duck.position.distanceTo(bug.position) < 1.5) {
                        bug.position.set((Math.random()-0.5)*200, 0.5, (Math.random()-0.5)*200);
                        score += 10;
                        hunger = Math.min(100, hunger + 15);
                        document.getElementById('scoreDisplay').innerText = `Score: ${Math.floor(score)}`;
                    }
                });
            }

            // 2. Animate Fishes (Schooling behavior)
            fishes.forEach(f => {
                f.angle += 0.02;
                f.mesh.position.x += Math.cos(f.angle) * 0.1;
                f.mesh.position.z += Math.sin(f.angle) * 0.1;
                f.mesh.rotation.y = -f.angle;
            });

            // 3. Animate Wakes (Expanding Path)
            for(let i = wakes.length - 1; i >= 0; i--) {
                const w = wakes[i];
                w.life -= 0.01;
                w.mesh.scale.x += 0.05;
                w.mesh.scale.y += 0.05;
                w.mesh.material.opacity = w.life;
                if(w.life <= 0) {
                    scene.remove(w.mesh);
                    wakes.splice(i, 1);
                }
            }

            // Camera
            const camOffset = new THREE.Vector3(0, 10, -20).applyMatrix4(duck.matrixWorld);
            camera.position.lerp(camOffset, 0.1);
            camera.lookAt(duck.position);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
